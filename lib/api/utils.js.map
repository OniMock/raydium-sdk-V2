{"version":3,"sources":["../../src/api/utils.ts"],"sourceRoot":"../src","sourcesContent":["export const SESSION_KEY = \"ray_tab_hash\";\r\nexport const STORAGE_KEY = \"ray_req_hash\";\r\n\r\nexport const getSessionKey = (): string => {\r\n  if (typeof window === undefined) return \"\";\r\n  let key = sessionStorage.getItem(SESSION_KEY);\r\n\r\n  // new a session key\r\n  if (!key) {\r\n    key = `ray-${Date.now()}`;\r\n    sessionStorage.setItem(SESSION_KEY, key);\r\n  }\r\n  return key;\r\n};\r\n\r\nexport interface ResHistory {\r\n  status: number;\r\n  url: string;\r\n  params?: any;\r\n  data: any;\r\n  logCount?: number;\r\n  time: number;\r\n  session: string;\r\n  removeLastLog?: boolean;\r\n}\r\n\r\nexport const updateReqHistory = async ({\r\n  logCount = 1000,\r\n  removeLastLog,\r\n  ...resData\r\n}: Omit<ResHistory, \"time\" | \"session\">): Promise<void> => {\r\n  if (typeof window === undefined) return new Promise((resolve) => resolve());\r\n  const data: ResHistory[] = JSON.parse(localStorage.getItem(STORAGE_KEY) || \"[]\").slice(0, logCount - 1);\r\n\r\n  // means retry last save error\r\n  if (removeLastLog) data.pop();\r\n\r\n  // if data > 1kb\r\n  if (new Blob([JSON.stringify(resData.data)]).size > 1024)\r\n    resData.data = JSON.stringify(resData.data).substring(0, 200) + \"...\";\r\n  data.unshift({ ...resData, time: Date.now(), session: getSessionKey() });\r\n\r\n  try {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n  } catch {\r\n    // if retry failed, empty request data\r\n    if (removeLastLog) {\r\n      let success = false;\r\n      const resStr = JSON.stringify(resData.data).substring(0, 100);\r\n      data[0].data = resStr + (resStr.length > 100 ? \"...\" : \"\");\r\n      while (!success) {\r\n        data.pop();\r\n        const resStr = JSON.stringify(resData.data).substring(0, 100);\r\n        data[0].data = resStr + (resStr.length > 100 ? \"...\" : \"\");\r\n        try {\r\n          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\r\n          success = true;\r\n        } catch {\r\n          success = false;\r\n        }\r\n      }\r\n      return new Promise((resolve) => resolve());\r\n    }\r\n    return updateReqHistory({\r\n      ...resData,\r\n      logCount,\r\n      removeLastLog: true,\r\n    });\r\n  }\r\n};\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO,IAAM,cAAc;AACpB,IAAM,cAAc;AAEpB,IAAM,gBAAgB,MAAc;AACzC,MAAI,OAAO,WAAW;AAAW,WAAO;AACxC,MAAI,MAAM,eAAe,QAAQ,WAAW;AAG5C,MAAI,CAAC,KAAK;AACR,UAAM,OAAO,KAAK,IAAI;AACtB,mBAAe,QAAQ,aAAa,GAAG;AAAA,EACzC;AACA,SAAO;AACT;AAaO,IAAM,mBAAmB,OAAO;AAAA,EACrC,WAAW;AAAA,EACX;AAAA,KACG;AAAA,MACsD;AACzD,MAAI,OAAO,WAAW;AAAW,WAAO,IAAI,QAAQ,CAAC,YAAY,QAAQ,CAAC;AAC1E,QAAM,OAAqB,KAAK,MAAM,aAAa,QAAQ,WAAW,KAAK,IAAI,EAAE,MAAM,GAAG,WAAW,CAAC;AAGtG,MAAI;AAAe,SAAK,IAAI;AAG5B,MAAI,IAAI,KAAK,CAAC,KAAK,UAAU,QAAQ,IAAI,CAAC,CAAC,EAAE,OAAO;AAClD,YAAQ,OAAO,KAAK,UAAU,QAAQ,IAAI,EAAE,UAAU,GAAG,GAAG,IAAI;AAClE,OAAK,QAAQ,KAAK,SAAS,MAAM,KAAK,IAAI,GAAG,SAAS,cAAc,EAAE,CAAC;AAEvE,MAAI;AACF,iBAAa,QAAQ,aAAa,KAAK,UAAU,IAAI,CAAC;AAAA,EACxD,QAAE;AAEA,QAAI,eAAe;AACjB,UAAI,UAAU;AACd,YAAM,SAAS,KAAK,UAAU,QAAQ,IAAI,EAAE,UAAU,GAAG,GAAG;AAC5D,WAAK,GAAG,OAAO,SAAU,QAAO,SAAS,MAAM,QAAQ;AACvD,aAAO,CAAC,SAAS;AACf,aAAK,IAAI;AACT,cAAM,UAAS,KAAK,UAAU,QAAQ,IAAI,EAAE,UAAU,GAAG,GAAG;AAC5D,aAAK,GAAG,OAAO,UAAU,SAAO,SAAS,MAAM,QAAQ;AACvD,YAAI;AACF,uBAAa,QAAQ,aAAa,KAAK,UAAU,IAAI,CAAC;AACtD,oBAAU;AAAA,QACZ,QAAE;AACA,oBAAU;AAAA,QACZ;AAAA,MACF;AACA,aAAO,IAAI,QAAQ,CAAC,YAAY,QAAQ,CAAC;AAAA,IAC3C;AACA,WAAO,iBAAiB;AAAA,SACnB;AAAA,MACH;AAAA,MACA,eAAe;AAAA,IACjB,CAAC;AAAA,EACH;AACF;","names":[]}