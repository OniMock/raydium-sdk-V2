{"version":3,"sources":["../../../src/raydium/liquidity/stable.ts","../../../src/marshmallow/index.ts","../../../src/marshmallow/buffer-layout.ts"],"sourceRoot":"../src","sourcesContent":["import { Connection, PublicKey } from \"@solana/web3.js\";\r\n\r\nimport { seq, struct, u64 } from \"../../marshmallow\";\r\n\r\nexport const MODEL_DATA_PUBKEY = new PublicKey(\"CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo\");\r\nconst ELEMENT_SIZE = 50000;\r\n\r\nexport const DataElement = struct([u64(\"x\"), u64(\"y\"), u64(\"price\")]);\r\n\r\nexport const modelDataInfoLayout = struct([\r\n  u64(\"accountType\"),\r\n  u64(\"status\"),\r\n  u64(\"multiplier\"),\r\n  u64(\"validDataCount\"),\r\n  seq(DataElement, ELEMENT_SIZE, \"DataElement\"),\r\n]);\r\n\r\nexport interface StableModelLayout {\r\n  accountType: number;\r\n  status: number;\r\n  multiplier: number;\r\n  validDataCount: number;\r\n  DataElement: { x: number; y: number; price: number }[];\r\n}\r\n\r\nfunction estimateRangeByXyReal(_xReal: number, _yReal: number): number[] {\r\n  return [0, ELEMENT_SIZE - 2];\r\n}\r\n\r\nfunction estimateRangeByX(_x: number): number[] {\r\n  return [0, ELEMENT_SIZE - 2];\r\n}\r\n\r\nfunction estimateRangeByY(_y: number): number[] {\r\n  return [0, ELEMENT_SIZE - 2];\r\n}\r\n\r\nfunction getMininumRangeByXyReal(\r\n  layoutData: StableModelLayout,\r\n  xReal: number,\r\n  yReal: number,\r\n): [number, number, boolean] {\r\n  const [min, max] = estimateRangeByXyReal(xReal, yReal);\r\n  let minRangeIdx = min;\r\n  let maxRangeIdx = max;\r\n  let mid = 0;\r\n  const target = (xReal * layoutData.multiplier) / yReal;\r\n  while (minRangeIdx <= maxRangeIdx) {\r\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\r\n    if (mid === 0 || mid >= ELEMENT_SIZE - 2) {\r\n      return [mid, mid, false];\r\n    }\r\n    const cur = (layoutData.DataElement[mid].x * layoutData.multiplier) / layoutData.DataElement[mid].y;\r\n    const left = (layoutData.DataElement[mid - 1].x * layoutData.multiplier) / layoutData.DataElement[mid - 1].y;\r\n    const right = (layoutData.DataElement[mid + 1].x * layoutData.multiplier) / layoutData.DataElement[mid + 1].y;\r\n\r\n    if (target === cur) {\r\n      return [mid, mid, true];\r\n    } else if (target === left) {\r\n      return [mid - 1, mid - 1, true];\r\n    } else if (target === right) {\r\n      return [mid + 1, mid + 1, true];\r\n    } else if (target < left) {\r\n      maxRangeIdx = mid - 1;\r\n    } else if (target > left && target < cur) {\r\n      return [mid - 1, mid, true];\r\n    } else if (target > cur && target < right) {\r\n      return [mid, mid + 1, true];\r\n    } else {\r\n      minRangeIdx = mid + 1;\r\n    }\r\n  }\r\n  return [mid, mid, false];\r\n}\r\nfunction getRatio(layoutData: StableModelLayout, xReal: number, yReal: number): number {\r\n  const [minRangeIdx, maxRangeIdx, find] = getMininumRangeByXyReal(layoutData, xReal, yReal);\r\n\r\n  if (!find) {\r\n    return 0;\r\n  }\r\n\r\n  if (minRangeIdx === maxRangeIdx) {\r\n    const x = layoutData.DataElement[minRangeIdx].x;\r\n    const ratio = (xReal * layoutData.multiplier) / x;\r\n    return ratio;\r\n  } else {\r\n    const x1 = layoutData.DataElement[minRangeIdx].x;\r\n    const y1 = layoutData.DataElement[minRangeIdx].y;\r\n    const x2 = layoutData.DataElement[maxRangeIdx].x;\r\n    const y2 = layoutData.DataElement[maxRangeIdx].y;\r\n\r\n    const xDenominator = yReal * (x2 * y1 - x1 * y2);\r\n    const xNumerator1 = x1 * xDenominator;\r\n    const xNumerator2 = (x2 - x1) * (xReal * y1 - x1 * yReal) * y2;\r\n\r\n    const xNumerator = xNumerator1 + xNumerator2;\r\n    const ratio = (xReal * layoutData.multiplier * xDenominator) / xNumerator;\r\n    return ratio;\r\n  }\r\n}\r\n\r\nfunction realToTable(layoutData: StableModelLayout, realValue: number, ratio: number): number {\r\n  return (realValue * layoutData.multiplier) / ratio;\r\n}\r\n\r\nfunction tableToReal(layoutData: StableModelLayout, tableValue: number, ratio: number): number {\r\n  return (tableValue * ratio) / layoutData.multiplier;\r\n}\r\n\r\nfunction getMinimumRangeByX(layoutData: StableModelLayout, x: number): [number, number, boolean] {\r\n  const [min, max] = estimateRangeByX(x);\r\n  let minRangeIdx = min;\r\n  let maxRangeIdx = max;\r\n  let mid = 0;\r\n  const target = x;\r\n  while (minRangeIdx < maxRangeIdx) {\r\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\r\n\r\n    if (mid <= 0 || mid > ELEMENT_SIZE - 2) {\r\n      return [mid, mid, false];\r\n    }\r\n    const cur = layoutData.DataElement[mid].x;\r\n    const left = layoutData.DataElement[mid - 1].x;\r\n    const right = layoutData.DataElement[mid + 1].x;\r\n\r\n    if (target === cur) return [mid, mid, true];\r\n    else if (target === left) return [mid - 1, mid - 1, true];\r\n    else if (target === right) return [mid + 1, mid + 1, true];\r\n    else if (target < left) maxRangeIdx = mid - 1;\r\n    else if (target > left && target < cur) return [mid - 1, mid, true];\r\n    else if (target > cur && target < right) return [mid, mid + 1, true];\r\n    else minRangeIdx = mid + 1;\r\n  }\r\n  return [mid, mid, false];\r\n}\r\n\r\nfunction getMinimumRangeByY(layoutData: StableModelLayout, y: number): [number, number, boolean] {\r\n  const [min, max] = estimateRangeByY(y);\r\n  let minRangeIdx = min;\r\n  let maxRangeIdx = max;\r\n  let mid = 0;\r\n  const target = y;\r\n  while (minRangeIdx <= maxRangeIdx) {\r\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\r\n    if (mid <= 0 || mid >= ELEMENT_SIZE - 2) {\r\n      return [mid, mid, false];\r\n    }\r\n\r\n    const cur = layoutData.DataElement[mid].y;\r\n    const left = layoutData.DataElement[mid - 1].y;\r\n    const right = layoutData.DataElement[mid + 1].y;\r\n    if (target === cur) return [mid, mid, true];\r\n    else if (target === left) return [mid - 1, mid - 1, true];\r\n    else if (target === right) return [mid + 1, mid + 1, true];\r\n    else if (target < right) {\r\n      minRangeIdx = mid + 1;\r\n    } else if (target < left && target > cur) return [mid - 1, mid, true];\r\n    else if (target < cur && target > right) return [mid, mid + 1, true];\r\n    else maxRangeIdx = mid - 1;\r\n  }\r\n  return [mid, mid, false];\r\n}\r\n\r\nfunction getDataByX(\r\n  layoutData: StableModelLayout,\r\n  x: number,\r\n  dx: number,\r\n  priceUp: boolean,\r\n): [number, number, boolean, boolean] {\r\n  const xWithDx = priceUp ? x + dx : x - dx;\r\n  const [minIdx, maxIdx, find] = getMinimumRangeByX(layoutData, xWithDx);\r\n  if (!find) return [0, 0, false, find];\r\n\r\n  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].y, false, find];\r\n  else {\r\n    const x1 = layoutData.DataElement[minIdx].x;\r\n    const x2 = layoutData.DataElement[maxIdx].x;\r\n    const p1 = layoutData.DataElement[minIdx].price;\r\n    const p2 = layoutData.DataElement[maxIdx].price;\r\n    const y1 = layoutData.DataElement[minIdx].y;\r\n    const y2 = layoutData.DataElement[maxIdx].y;\r\n\r\n    if (x >= x1 && x <= x2) {\r\n      if (priceUp) return [p2, y2, true, find];\r\n      else return [p1, y1, true, find];\r\n    } else {\r\n      let p, y;\r\n      if (priceUp) {\r\n        p = p1 + ((p2 - p1) * (x - x1)) / (x2 - x1);\r\n        y = y1 - ((xWithDx - x1) * layoutData.multiplier) / p2;\r\n      } else {\r\n        p = p1 + ((p2 - p1) * (x - x1)) / (x2 - x1);\r\n        y = y2 + ((x2 - xWithDx) * layoutData.multiplier) / p1;\r\n      }\r\n      return [p, y, false, find];\r\n    }\r\n  }\r\n}\r\n\r\nfunction getDataByY(\r\n  layoutData: StableModelLayout,\r\n  y: number,\r\n  dy: number,\r\n  priceUp: boolean,\r\n): [number, number, boolean, boolean] {\r\n  const yWithDy = priceUp ? y - dy : y + dy;\r\n  const [minIdx, maxIdx, find] = getMinimumRangeByY(layoutData, yWithDy);\r\n  if (!find) return [0, 0, false, find];\r\n  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].x, false, find];\r\n  else {\r\n    const x1 = layoutData.DataElement[minIdx].x;\r\n    const x2 = layoutData.DataElement[maxIdx].x;\r\n    const p1 = layoutData.DataElement[minIdx].price;\r\n    const p2 = layoutData.DataElement[maxIdx].price;\r\n    const y1 = layoutData.DataElement[minIdx].y;\r\n    const y2 = layoutData.DataElement[maxIdx].y;\r\n\r\n    if (y >= y2 && y <= y1) {\r\n      return priceUp ? [p2, x2, true, find] : [p1, x1, true, find];\r\n    } else {\r\n      let p, x;\r\n      if (priceUp) {\r\n        p = p1 + ((p2 - p1) * (y1 - y)) / (y1 - y2);\r\n        x = x1 + (p2 * (y1 - yWithDy)) / layoutData.multiplier;\r\n      } else {\r\n        p = p1 + ((p2 - p1) * (y1 - y)) / (y1 - y2);\r\n        x = x2 - (p1 * (yWithDy - y2)) / layoutData.multiplier;\r\n      }\r\n      return [p, x, false, find];\r\n    }\r\n  }\r\n}\r\n\r\nfunction getMidPrice(layoutData: StableModelLayout, x: number): number {\r\n  const ret = getDataByX(layoutData, x, 0, false);\r\n  if (ret[3]) return ret[0];\r\n  else return 0;\r\n}\r\n\r\nexport function getDyByDxBaseIn(layoutData: StableModelLayout, xReal: number, yReal: number, dxReal: number): number {\r\n  const ratio = getRatio(layoutData, xReal, yReal);\r\n  const x = realToTable(layoutData, xReal, ratio);\r\n  const y = realToTable(layoutData, yReal, ratio);\r\n  const dx = realToTable(layoutData, dxReal, ratio);\r\n  const priceUp = true;\r\n  const [p, y2, lessTrade, find] = getDataByX(layoutData, x, dx, priceUp);\r\n  if (!find) return 0;\r\n  if (lessTrade) {\r\n    const dyReal = (dxReal * layoutData.multiplier) / p;\r\n    return dyReal;\r\n  } else {\r\n    const dy = y - y2;\r\n    const dyReal = tableToReal(layoutData, dy, ratio);\r\n    return dyReal;\r\n  }\r\n}\r\n\r\nexport function getDxByDyBaseIn(layoutData: StableModelLayout, xReal: number, yReal: number, dyReal: number): number {\r\n  const ratio = getRatio(layoutData, xReal, yReal);\r\n  const x = realToTable(layoutData, xReal, ratio);\r\n  const y = realToTable(layoutData, yReal, ratio);\r\n  const dy = realToTable(layoutData, dyReal, ratio);\r\n  const priceUp = false;\r\n  const [p, x2, lessTrade, find] = getDataByY(layoutData, y, dy, priceUp);\r\n  if (!find) return 0;\r\n  if (lessTrade) {\r\n    const dxReal = (dyReal * p) / layoutData.multiplier;\r\n    return dxReal;\r\n  } else {\r\n    const dx = x - x2;\r\n    const dxReal = tableToReal(layoutData, dx, ratio);\r\n    return dxReal;\r\n  }\r\n}\r\n\r\nexport function formatLayout(buffer: Buffer): StableModelLayout {\r\n  const layoutInfo = modelDataInfoLayout.decode(buffer);\r\n  return {\r\n    accountType: layoutInfo.accountType.toNumber(),\r\n    status: layoutInfo.status.toNumber(),\r\n    multiplier: layoutInfo.multiplier.toNumber(),\r\n    validDataCount: layoutInfo.validDataCount.toNumber(),\r\n    DataElement: layoutInfo.DataElement.map((item: any) => ({\r\n      x: item.x.toNumber(),\r\n      y: item.y.toNumber(),\r\n      price: item.price.toNumber(),\r\n    })),\r\n  };\r\n}\r\n\r\nexport function getStablePrice(\r\n  layoutData: StableModelLayout,\r\n  coinReal: number,\r\n  pcReal: number,\r\n  baseCoin: boolean,\r\n): number {\r\n  const price =\r\n    getMidPrice(layoutData, realToTable(layoutData, coinReal, getRatio(layoutData, coinReal, pcReal))) /\r\n    layoutData.multiplier;\r\n  return baseCoin ? price : 1 / price;\r\n}\r\n\r\nexport class StableLayout {\r\n  private readonly connection: Connection;\r\n  private _layoutData: StableModelLayout = {\r\n    accountType: 0,\r\n    status: 0,\r\n    multiplier: 0,\r\n    validDataCount: 0,\r\n    DataElement: [],\r\n  };\r\n\r\n  constructor({ connection }: { connection: Connection }) {\r\n    this.connection = connection;\r\n  }\r\n\r\n  get stableModelData(): StableModelLayout {\r\n    return this._layoutData;\r\n  }\r\n\r\n  public async initStableModelLayout(): Promise<void> {\r\n    if (this._layoutData.validDataCount === 0) {\r\n      if (this.connection) {\r\n        const acc = await this.connection.getAccountInfo(MODEL_DATA_PUBKEY);\r\n        if (acc) this._layoutData = formatLayout(acc?.data);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { PublicKey } from \"@solana/web3.js\";\r\nimport BN, { isBN } from \"bn.js\";\r\n\r\nimport {\r\n  bits,\r\n  blob,\r\n  Blob,\r\n  Layout,\r\n  offset as _offset,\r\n  seq as _seq,\r\n  Structure as _Structure,\r\n  u32 as _u32,\r\n  u8 as _u8,\r\n  UInt,\r\n  union as _union,\r\n  Union as _Union,\r\n} from \"./buffer-layout\";\r\n\r\nexport * from \"./buffer-layout\";\r\nexport { blob };\r\n\r\nexport class BNLayout<P extends string = \"\"> extends Layout<BN, P> {\r\n  blob: Layout<Buffer>;\r\n  signed: boolean;\r\n\r\n  constructor(span: number, signed: boolean, property?: P) {\r\n    //@ts-expect-error type wrong for super()'s type different from extends, but it desn't matter\r\n    super(span, property);\r\n    this.blob = blob(span);\r\n    this.signed = signed;\r\n  }\r\n\r\n  /** @override */\r\n  decode(b: Buffer, offset = 0): BN {\r\n    const num = new BN(this.blob.decode(b, offset), 10, \"le\");\r\n    if (this.signed) {\r\n      return num.fromTwos(this.span * 8).clone();\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /** @override */\r\n  encode(src: BN, b: Buffer, offset = 0): number {\r\n    if (typeof src === \"number\") src = new BN(src); // src will pass a number accidently in union\r\n    if (this.signed) {\r\n      src = src.toTwos(this.span * 8);\r\n    }\r\n    return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\r\n  }\r\n}\r\n\r\nexport class WideBits<P extends string = \"\"> extends Layout<Record<string, boolean>, P> {\r\n  _lower: any;\r\n  _upper: any;\r\n  // TODO: unknown\r\n  constructor(property?: P) {\r\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\r\n    super(8, property);\r\n    this._lower = bits(_u32(), false);\r\n    this._upper = bits(_u32(), false);\r\n  }\r\n\r\n  addBoolean(property: string): void {\r\n    if (this._lower.fields.length < 32) {\r\n      this._lower.addBoolean(property);\r\n    } else {\r\n      this._upper.addBoolean(property);\r\n    }\r\n  }\r\n\r\n  decode(b: Buffer, offset = 0): Record<string, boolean> {\r\n    const lowerDecoded = this._lower.decode(b, offset);\r\n    const upperDecoded = this._upper.decode(b, offset + this._lower.span);\r\n    return { ...lowerDecoded, ...upperDecoded };\r\n  }\r\n\r\n  encode(src: any /* TEMP */, b: Buffer, offset = 0): any {\r\n    return this._lower.encode(src, b, offset) + this._upper.encode(src, b, offset + this._lower.span);\r\n  }\r\n}\r\n\r\nexport function u8<P extends string = \"\">(property?: P): UInt<number, P> {\r\n  return new UInt(1, property);\r\n}\r\n\r\nexport function u32<P extends string = \"\">(property?: P): UInt<number, P> {\r\n  return new UInt(4, property);\r\n}\r\n\r\nexport function u64<P extends string = \"\">(property?: P): BNLayout<P> {\r\n  return new BNLayout(8, false, property);\r\n}\r\n\r\nexport function u128<P extends string = \"\">(property?: P): BNLayout<P> {\r\n  return new BNLayout(16, false, property);\r\n}\r\n\r\nexport function i8<P extends string = \"\">(property?: P): BNLayout<P> {\r\n  return new BNLayout(1, true, property);\r\n}\r\n\r\nexport function i64<P extends string = \"\">(property?: P): BNLayout<P> {\r\n  return new BNLayout(8, true, property);\r\n}\r\n\r\nexport function i128<P extends string = \"\">(property?: P): BNLayout<P> {\r\n  return new BNLayout(16, true, property);\r\n}\r\n\r\nexport class WrappedLayout<T, U, P extends string = \"\"> extends Layout<U, P> {\r\n  layout: Layout<T>;\r\n  decoder: (data: T) => U;\r\n  encoder: (src: U) => T;\r\n\r\n  constructor(layout: Layout<T>, decoder: (data: T) => U, encoder: (src: U) => T, property?: P) {\r\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\r\n    super(layout.span, property);\r\n    this.layout = layout;\r\n    this.decoder = decoder;\r\n    this.encoder = encoder;\r\n  }\r\n\r\n  decode(b: Buffer, offset?: number): U {\r\n    return this.decoder(this.layout.decode(b, offset));\r\n  }\r\n\r\n  encode(src: U, b: Buffer, offset?: number): number {\r\n    return this.layout.encode(this.encoder(src), b, offset);\r\n  }\r\n\r\n  getSpan(b: Buffer, offset?: number): number {\r\n    return this.layout.getSpan(b, offset);\r\n  }\r\n}\r\n\r\nexport function publicKey<P extends string = \"\">(property?: P): Layout<PublicKey, P> {\r\n  return new WrappedLayout(\r\n    blob(32),\r\n    (b: Buffer) => new PublicKey(b),\r\n    (key: PublicKey) => key.toBuffer(),\r\n    property,\r\n  );\r\n}\r\n\r\nexport class OptionLayout<T, P> extends Layout<T | null, P> {\r\n  layout: Layout<T>;\r\n  discriminator: Layout<number>;\r\n\r\n  constructor(layout: Layout<T>, property?: P) {\r\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\r\n    super(-1, property);\r\n    this.layout = layout;\r\n    this.discriminator = _u8();\r\n  }\r\n\r\n  encode(src: T | null, b: Buffer, offset = 0): number {\r\n    if (src === null || src === undefined) {\r\n      return this.discriminator.encode(0, b, offset);\r\n    }\r\n    this.discriminator.encode(1, b, offset);\r\n    return this.layout.encode(src, b, offset + 1) + 1;\r\n  }\r\n\r\n  decode(b: Buffer, offset = 0): T | null {\r\n    const discriminator = this.discriminator.decode(b, offset);\r\n    if (discriminator === 0) {\r\n      return null;\r\n    } else if (discriminator === 1) {\r\n      return this.layout.decode(b, offset + 1);\r\n    }\r\n    throw new Error(\"Invalid option \" + this.property);\r\n  }\r\n\r\n  getSpan(b: Buffer, offset = 0): number {\r\n    const discriminator = this.discriminator.decode(b, offset);\r\n    if (discriminator === 0) {\r\n      return 1;\r\n    } else if (discriminator === 1) {\r\n      return this.layout.getSpan(b, offset + 1) + 1;\r\n    }\r\n    throw new Error(\"Invalid option \" + this.property);\r\n  }\r\n}\r\n\r\nexport function option<T, P extends string = \"\">(layout: Layout<T>, property?: P): Layout<T | null, P> {\r\n  return new OptionLayout<T, P>(layout, property);\r\n}\r\n\r\nexport function bool<P extends string = \"\">(property?: P): Layout<boolean, P> {\r\n  return new WrappedLayout(_u8(), decodeBool, encodeBool, property);\r\n}\r\n\r\nexport function decodeBool(value: number): boolean {\r\n  if (value === 0) {\r\n    return false;\r\n  } else if (value === 1) {\r\n    return true;\r\n  }\r\n  throw new Error(\"Invalid bool: \" + value);\r\n}\r\n\r\nexport function encodeBool(value: boolean): number {\r\n  return value ? 1 : 0;\r\n}\r\n\r\nexport function vec<T, P extends string = \"\">(elementLayout: Layout<T>, property?: P): Layout<T[], P> {\r\n  const length = _u32(\"length\");\r\n  const layout: Layout<{ values: T[] }> = struct([\r\n    length,\r\n    seq(elementLayout, _offset(length, -length.span), \"values\"),\r\n  ]) as any; // Something I don't know\r\n  return new WrappedLayout(\r\n    layout,\r\n    ({ values }) => values,\r\n    (values) => ({ values }),\r\n    property,\r\n  );\r\n}\r\n\r\nexport function tagged<T, P extends string = \"\">(tag: BN, layout: Layout<T>, property?: P): Layout<T, P> {\r\n  const wrappedLayout: Layout<{ tag: BN; data: T }> = struct([u64(\"tag\"), layout.replicate(\"data\")]) as any; // Something I don't know\r\n\r\n  function decodeTag({ tag: receivedTag, data }: { tag: BN; data: T }): T {\r\n    if (!receivedTag.eq(tag)) {\r\n      throw new Error(\"Invalid tag, expected: \" + tag.toString(\"hex\") + \", got: \" + receivedTag.toString(\"hex\"));\r\n    }\r\n    return data;\r\n  }\r\n\r\n  return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\r\n}\r\n\r\nexport function vecU8<P extends string = \"\">(property?: P): Layout<Buffer, P> {\r\n  const length = _u32(\"length\");\r\n  const layout: Layout<{ data: Buffer }> = struct([length, blob(_offset(length, -length.span), \"data\")]) as any; // Something I don't know\r\n  return new WrappedLayout(\r\n    layout,\r\n    ({ data }) => data,\r\n    (data) => ({ data }),\r\n    property,\r\n  );\r\n}\r\n\r\nexport function str<P extends string = \"\">(property?: P): Layout<string, P> {\r\n  return new WrappedLayout(\r\n    vecU8(),\r\n    (data) => data.toString(\"utf-8\"),\r\n    (s) => Buffer.from(s, \"utf-8\"),\r\n    property,\r\n  );\r\n}\r\n\r\nexport interface EnumLayout<T, P extends string = \"\"> extends Layout<T, P> {\r\n  registry: Record<string, Layout<any>>;\r\n}\r\n\r\nexport function rustEnum<T, P extends string = \"\">(variants: Layout<any>[], property?: P): EnumLayout<T, P> {\r\n  const unionLayout = _union(_u8(), property);\r\n  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\r\n  return unionLayout as any; // ?why use UnionLayout? This must be a fault\r\n}\r\n\r\nexport function array<T, P extends string = \"\">(\r\n  elementLayout: Layout<T>,\r\n  length: number,\r\n  property?: P,\r\n): Layout<T[], P> {\r\n  const layout = struct([seq(elementLayout, length, \"values\")]) as any as Layout<{ values: T[] }>; // Something I don't know\r\n  return new WrappedLayout(\r\n    layout,\r\n    ({ values }) => values,\r\n    (values) => ({ values }),\r\n    property,\r\n  );\r\n}\r\n\r\nexport class Structure<T, P, D extends { [key: string]: any; }> extends _Structure<T, P, D> {\r\n  /** @override */\r\n  decode(b: Buffer, offset?: number): D {\r\n    return super.decode(b, offset);\r\n  }\r\n}\r\n\r\nexport function struct<T, P extends string = \"\">(\r\n  fields: T,\r\n  property?: P,\r\n  decodePrefixes?: boolean,\r\n): T extends Layout<infer Value, infer Property>[]\r\n  ? Structure<\r\n    Value,\r\n    P,\r\n    {\r\n      [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\r\n      ? V\r\n      : any;\r\n    }\r\n  >\r\n  : any {\r\n  //@ts-expect-error this type is not quite satisfied the define, but, never no need to worry about.\r\n  return new Structure(fields, property, decodePrefixes);\r\n}\r\n\r\nexport type GetLayoutSchemaFromStructure<T extends Structure<any, any, any>> = T extends Structure<any, any, infer S>\r\n  ? S\r\n  : any;\r\nexport type GetStructureFromLayoutSchema<S extends { [key: string]: any; }> = Structure<any, any, S>;\r\n\r\nexport class Union<Schema extends { [key: string]: any; }> extends _Union<Schema> {\r\n  encodeInstruction(instruction: any): Buffer {\r\n    const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));\r\n    const b = Buffer.alloc(instructionMaxSpan);\r\n    return b.slice(0, this.encode(instruction, b));\r\n  }\r\n\r\n  decodeInstruction(instruction: any): Partial<Schema> {\r\n    return this.decode(instruction);\r\n  }\r\n}\r\nexport function union<UnionSchema extends { [key: string]: any } = any>(\r\n  discr: any,\r\n  defaultLayout?: any,\r\n  property?: string,\r\n): Union<UnionSchema> {\r\n  return new Union(discr, defaultLayout, property);\r\n}\r\n\r\nclass Zeros extends Blob {\r\n  decode(b: Buffer, offset: number): Buffer {\r\n    const slice = super.decode(b, offset);\r\n    if (!slice.every((v) => v === 0)) {\r\n      throw new Error(\"nonzero padding bytes\");\r\n    }\r\n    return slice;\r\n  }\r\n}\r\n\r\nexport function zeros(length: number): Zeros {\r\n  return new Zeros(length);\r\n}\r\n\r\nexport function seq<T, P extends string = \"\", AnotherP extends string = \"\">(\r\n  elementLayout: Layout<T, P>,\r\n  count: number | BN | Layout<BN | number, P>,\r\n  property?: AnotherP,\r\n): Layout<T[], AnotherP> {\r\n  let parsedCount: number;\r\n  const superCount =\r\n    typeof count === \"number\"\r\n      ? count\r\n      : isBN(count)\r\n        ? count.toNumber()\r\n        : new Proxy(count as unknown as Layout<number> /* pretend to be Layout<number> */, {\r\n          get(target, property): any {\r\n            if (!parsedCount) {\r\n              // get count in targetLayout. note that count may be BN\r\n              const countProperty = Reflect.get(target, \"count\");\r\n\r\n              // let targetLayout's  property:count be a number\r\n              parsedCount = isBN(countProperty) ? countProperty.toNumber() : countProperty;\r\n\r\n              // record the count\r\n              Reflect.set(target, \"count\", parsedCount);\r\n            }\r\n            return Reflect.get(target, property);\r\n          },\r\n          set(target, property, value): any {\r\n            if (property === \"count\") {\r\n              parsedCount = value;\r\n            }\r\n            return Reflect.set(target, property, value);\r\n          },\r\n        });\r\n\r\n  // @ts-expect-error force type\r\n  return _seq(elementLayout, superCount, property);\r\n}\r\n","import {\r\n  bits as _bits,\r\n  BitStructure as _BitStructure,\r\n  blob as _blob,\r\n  Blob as _Blob,\r\n  cstr as _cstr,\r\n  f32 as _f32,\r\n  f32be as _f32be,\r\n  f64 as _f64,\r\n  f64be as _f64be,\r\n  greedy as _greedy,\r\n  Layout as _Layout,\r\n  ns64 as _ns64,\r\n  ns64be as _ns64be,\r\n  nu64 as _nu64,\r\n  nu64be as _nu64be,\r\n  offset as _offset,\r\n  s16 as _s16,\r\n  s16be as _s16be,\r\n  s24 as _s24,\r\n  s24be as _s24be,\r\n  s32 as _s32,\r\n  s32be as _s32be,\r\n  s40 as _s40,\r\n  s40be as _s40be,\r\n  s48 as _s48,\r\n  s48be as _s48be,\r\n  s8 as _s8,\r\n  seq as _seq,\r\n  struct as _struct,\r\n  Structure as _Structure,\r\n  u16 as _u16,\r\n  u16be as _u16be,\r\n  u24 as _u24,\r\n  u24be as _u24be,\r\n  u32 as _u32,\r\n  u32be as _u32be,\r\n  u40 as _u40,\r\n  u40be as _u40be,\r\n  u48 as _u48,\r\n  u48be as _u48be,\r\n  u8 as _u8,\r\n  UInt as _UInt,\r\n  union as _union,\r\n  Union as _Union,\r\n  unionLayoutDiscriminator as _unionLayoutDiscriminator,\r\n  utf8 as _utf8,\r\n} from \"@solana/buffer-layout\";\r\n\r\n//#region ------------------- Layout -------------------\r\nexport interface Layout<T = any, P = \"\"> {\r\n  span: number;\r\n  property?: P;\r\n  decode(b: Buffer, offset?: number): T;\r\n  encode(src: T, b: Buffer, offset?: number): number;\r\n  getSpan(b: Buffer, offset?: number): number;\r\n  replicate<AP extends string>(name: AP): Layout<T, AP>;\r\n}\r\nexport interface LayoutConstructor {\r\n  new <T, P>(): Layout<T, P>; // for class extends syntex\r\n  new <T, P>(span?: T, property?: P): Layout<T, P>;\r\n  readonly prototype: Layout;\r\n}\r\nexport const Layout = _Layout as unknown as LayoutConstructor;\r\n//#endregion\r\n\r\n//#region ------------------- Structure -------------------\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport interface Structure<T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>\r\n  extends Layout<DecodeSchema, P> {\r\n  span: number;\r\n  decode(b: Buffer, offset?: number): DecodeSchema;\r\n  layoutFor<AP extends string>(property: AP): Layout<DecodeSchema[AP]>;\r\n  offsetOf<AP extends string>(property: AP): number;\r\n}\r\ninterface StructureConstructor {\r\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(): Structure<T, P, DecodeSchema>;\r\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(\r\n    fields: T,\r\n    property?: P,\r\n    decodePrefixes?: boolean,\r\n  ): Structure<T, P, DecodeSchema>;\r\n}\r\nexport const Structure = _Structure as unknown as StructureConstructor;\r\n//#endregion\r\n\r\n//#region ------------------- Union -------------------\r\nexport interface Union<UnionSchema extends { [key: string]: any } = any> extends Layout {\r\n  registry: object;\r\n  decode(b: Buffer, offset?: number): Partial<UnionSchema>;\r\n  addVariant(\r\n    variant: number,\r\n    layout: Structure<any, any, Partial<UnionSchema>> | Layout<any, keyof UnionSchema>,\r\n    property?: string,\r\n  ): any /* TEMP: code in Layout.js 1809 */;\r\n}\r\ninterface UnionConstructor {\r\n  new <UnionSchema extends { [key: string]: any } = any>(): Union<UnionSchema>;\r\n  new <UnionSchema extends { [key: string]: any } = any>(\r\n    discr: Layout<any, any>,\r\n    defaultLayout: Layout<any, any>,\r\n    property?: string,\r\n  ): Union<UnionSchema>;\r\n}\r\nexport const Union = _Union as unknown as UnionConstructor;\r\n//#endregion\r\n\r\n//#region ------------------- BitStructure -------------------\r\nexport type BitStructure<T = unknown /* TEMP */, P = \"\"> = Layout<T, P>;\r\ninterface BitStructureConstructor {\r\n  new (...params: any[]): BitStructure;\r\n}\r\nexport const BitStructure = _BitStructure as BitStructureConstructor;\r\n//#endregion\r\n\r\n//#region ------------------- UInt -------------------\r\nexport type UInt<T = any, P = \"\"> = Layout<T, P>;\r\ninterface UIntConstructor {\r\n  new <T, P>(span?: T, property?: P): UInt<T, P>;\r\n}\r\nexport const UInt = _UInt as UIntConstructor;\r\n//#endregion\r\n\r\n//#region ------------------- Blob -------------------\r\nexport type Blob<P extends string = \"\"> = Layout<Buffer, P>;\r\ninterface BlobConstructor {\r\n  new (...params: ConstructorParameters<LayoutConstructor>): Blob;\r\n}\r\nexport const Blob = _Blob as unknown as BlobConstructor;\r\n//#endregion\r\n\r\nexport const greedy = _greedy as <P extends string = \"\">(elementSpan?: number, property?: P) => Layout<number, P>;\r\nexport const u8 = _u8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u16 = _u16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u24 = _u24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u32 = _u32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u40 = _u40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u48 = _u48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const nu64 = _nu64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u16be = _u16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u24be = _u24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u32be = _u32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u40be = _u40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const u48be = _u48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const nu64be = _nu64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s8 = _s8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s16 = _s16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s24 = _s24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s32 = _s32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s40 = _s40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s48 = _s48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const ns64 = _ns64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s16be = _s16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s24be = _s24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s32be = _s32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s40be = _s40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const s48be = _s48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const ns64be = _ns64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const f32 = _f32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const f32be = _f32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const f64 = _f64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\nexport const f64be = _f64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\r\n\r\nexport const struct = _struct as <T, P extends string = \"\">(\r\n  fields: T,\r\n  property?: P,\r\n  decodePrefixes?: boolean,\r\n) => T extends Layout<infer Value, infer Property>[]\r\n  ? Structure<\r\n      Value,\r\n      P,\r\n      {\r\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\r\n          ? V\r\n          : any;\r\n      }\r\n    >\r\n  : any;\r\n\r\nexport const seq = _seq as unknown as <T, P>(\r\n  elementLayout: Layout<T, string>,\r\n  count: number | Layout<number, string>,\r\n  property?: P,\r\n) => Layout<T[]>;\r\nexport const union = _union as <UnionSchema extends { [key: string]: any } = any>(\r\n  discr: Layout<any, any>,\r\n  defaultLayout?: any,\r\n  property?: string,\r\n) => Union<UnionSchema>;\r\nexport const unionLayoutDiscriminator = _unionLayoutDiscriminator as <P extends string = \"\">(\r\n  layout: Layout<any, P>,\r\n  property?: P,\r\n) => any;\r\nexport const blob = _blob as unknown as <P extends string = \"\">(\r\n  length: number | Layout<number, P>,\r\n  property?: P,\r\n) => Blob<P>;\r\nexport const cstr = _cstr as <P extends string = \"\">(property?: P) => Layout<string, P>;\r\nexport const utf8 = _utf8 as <P extends string = \"\">(maxSpan: number, property?: P) => Layout<string, P>;\r\nexport const bits = _bits as unknown as <T, P extends string = \"\">(\r\n  word: Layout<T>,\r\n  msb?: boolean,\r\n  property?: P,\r\n) => BitStructure<T, P>; // TODO: not quite sure\r\nexport const offset = _offset as unknown as <T, P extends string = \"\">(\r\n  layout: Layout<T, P>,\r\n  offset?: number,\r\n  property?: P,\r\n) => Layout<T, P>;\r\n\r\nexport type GetStructureSchema<T extends Structure> = T extends Structure<any, any, infer S> ? S : unknown;\r\n"],"mappings":"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","names":[]}